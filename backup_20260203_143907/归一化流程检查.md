# 归一化流程检查清单

## 当前实现检查

### ✅ 正确实现的部分

1. **训练时归一化**
   ```python
   # src/preprocessing/data_preprocessor.py L146
   features = self.scaler.fit_transform(features)
   self.fitted = True
   ```

2. **测试时使用相同scaler**
   ```python
   # src/preprocessing/data_preprocessor.py L168
   features = self.scaler.transform(features)
   ```

3. **Scaler保存**
   - 训练pipeline中应该保存scaler
   - 推理时应该加载相同的scaler

### ⚠️ 需要确认的部分

1. **目标变量归一化**
   - 当前代码中，目标变量`y`没有归一化
   - 这是正确的，因为我们预测的是kW值
   - 但需要确认训练时是否一致

2. **预测值的尺度**
   - 模型输出应该与`y`的尺度匹配
   - 如果`y`未归一化，则预测值也应该是原始尺度

3. **状态分类使用的数据**
   - 状态分类器应该使用**原始尺度**的预测值
   - 不应该使用归一化后的值

### ❌ 可能的问题

从实验结果看（MAPE=151%），可能存在以下问题：

1. **训练/推理不一致**
   ```python
   # 检查点：
   # 1. 训练时y是否归一化？
   # 2. 推理时预测值是否需要反归一化？
   # 3. 状态分类器接收的是什么尺度的值？
   ```

2. **窗口数据尺度**
   ```python
   # 状态分类器中：
   def predict(self, data, window_data=None):
       # window_data应该使用什么尺度？
       # 原始尺度 vs 归一化尺度
   ```

## 修复建议

### 方案1: 保持y不归一化（推荐）

```python
# 优点：预测值直接可用，无需反归一化
# 当前实现已经如此

# 训练
X, y = preprocessor.fit_transform(df)  # X归一化，y原始尺度
model.fit(X, y)

# 推理
X_test, y_test = preprocessor.transform(df_test)
y_pred = model.predict(X_test)  # 直接是原始尺度

# 状态分类
states = classifier.predict(y_pred, window_data=y_test[-80:])
```

### 方案2: y也归一化（需修改）

```python
# 需要添加y的scaler

class EnergyDataPreprocessor:
    def __init__(self, ...):
        self.scaler_X = StandardScaler()
        self.scaler_y = StandardScaler()
    
    def fit_transform(self, df):
        X_scaled = self.scaler_X.fit_transform(features)
        y_scaled = self.scaler_y.fit_transform(target.reshape(-1, 1)).flatten()
        return X, y_scaled
    
    def inverse_transform_y(self, y_pred):
        return self.scaler_y.inverse_transform(y_pred.reshape(-1, 1)).flatten()
```

## 验证步骤

### 1. 检查训练数据尺度
```python
import pickle

# 加载训练好的预处理器
with open('outputs/training/models/preprocessor.pkl', 'rb') as f:
    preprocessor = pickle.load(f)

# 检查
print(f"X scaler fitted: {preprocessor.fitted}")
print(f"X scaler mean: {preprocessor.scaler.mean_}")
print(f"X scaler scale: {preprocessor.scaler.scale_}")

# 是否有y scaler?
has_y_scaler = hasattr(preprocessor, 'scaler_y')
print(f"Has y scaler: {has_y_scaler}")
```

### 2. 检查预测值范围
```python
# 对比预测值与真实值的范围
print(f"y_true range: [{y_test.min()}, {y_test.max()}]")
print(f"y_pred range: [{y_pred.min()}, {y_pred.max()}]")

# 应该在相同量级
if abs(y_pred.mean() / y_test.mean() - 1) > 0.5:
    print("⚠️ 预测值与真实值尺度不匹配！")
```

### 3. 检查状态分类输入
```python
# 确认状态分类器使用正确尺度
window_data = y_test[-80:]  # 应该是原始尺度
print(f"Window data range: [{window_data.min()}, {window_data.max()}]")
print(f"Window data mean: {window_data.mean()}")

# 预测状态
states, z_scores = classifier.predict_with_scores(y_pred, window_data)
print(f"Z-scores range: [{z_scores.min()}, {z_scores.max()}]")
```

## 推荐的完整流程

```python
# === 训练阶段 ===
from src.preprocessing.data_preprocessor import EnergyDataPreprocessor
from src.models.predictor import ParallelCNNLSTMAttention
from src.models.state_classifier import SnStateClassifier

# 1. 预处理（X归一化，y保持原始尺度）
preprocessor = EnergyDataPreprocessor(
    sequence_length=80,
    feature_cols=['Global_active_power', 'Voltage', ...],
    target_col='Global_active_power'
)
X_train, y_train = preprocessor.fit_transform(train_df)

# 2. 训练模型
model = ParallelCNNLSTMAttention(input_shape=(80, n_features))
model.compile(optimizer='adam', loss='mse')
model.fit(X_train, y_train)

# 3. 训练状态分类器（使用原始尺度的y）
classifier = SnStateClassifier()
classifier.fit(y_train)

# === 推理阶段 ===

# 1. 预处理测试数据
X_test, y_test = preprocessor.transform(test_df)

# 2. 预测（输出原始尺度）
y_pred = model.predict(X_test).flatten()

# 3. 状态分类（使用原始尺度）
for i in range(len(y_pred)):
    window_start = max(0, i - 80)
    window_data = y_test[window_start:i+1]  # 原始尺度
    
    state = classifier.predict(y_pred[i], window_data)
    print(f"Sample {i}: pred={y_pred[i]:.3f}, state={state}")
```

## 行动项

- [ ] 检查当前训练代码中y是否归一化
- [ ] 检查推理代码中预测值尺度
- [ ] 确认状态分类器输入的数据尺度
- [ ] 如有问题，按方案1或方案2修复
- [ ] 重新训练和测试
- [ ] 验证MAPE降至合理范围（<20%）
